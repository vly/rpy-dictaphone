\begin{lstlisting}[caption=basic-service.h,language=C++]
#ifndef __BASE_SERVICE_H__
#define __BASE_SERVICE_H__

#include "message.h"
#include "message_query.h"

class base_service {
public:

  virtual bool setUpService()  = 0;
  virtual void startMainLoop() = 0;
  virtual void stopMainLoop()  = 0;

  virtual void postMessage(Message *m)
  {
    MessageQuery::GetInstance()->pushMessage(m);
  }

  virtual void receiveMessage(const Message& m) = 0;
};

#endif
\end{lstlisting}




\begin{lstlisting}[caption=client.h,language=C++]
#include "comm.h"
#include "singleton.h"
#include "base_service.h"

class Client : public Comm
               , public Singleton<Client>
               , public base_service {
  pthread_t input_thread;
  bool isRecording;

public:

  bool isRunning;

  Client();
  ~Client();

  virtual bool setUpService();
  virtual void startMainLoop();
  virtual void stopMainLoop();
  virtual void receiveMessage(const Message& m);
  virtual bool dispatchMessage(Message *m);

private:

  void connectToServer();
  int  sendCommand(char *);
  void startAudioRecording();
  void stopAudioRecording();
};
\end{lstlisting}





\begin{lstlisting}[caption=client.cpp,language=C++]
#include "client.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define HOSTNAME "192.168.1.126"

Client::Client()
  : isRecording(false)
    , isRunning(true)
{}

Client::~Client()
{
  printf("shut down recording");
  sendCommand("shutdown\r");
}

void Client::connectToServer()
{
  if (connect(client_socket, (struct sockaddr *)&serv_addr,
              sizeof(serv_addr)) < 0)
  {
    printf("\n Error: Connect Failed\n");
    exit(1);
  }
}

void* inputFunction(void *arg)
{
  Client *client = (Client *)arg;

  char c;

  scanf("%c", &c);

  if (c == 27) client->isRunning = false;

  return NULL;
}

bool Client::setUpService()
{
  memset(&serv_addr, 0, sizeof(struct sockaddr_in));

  if ((client_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0)
  {
    printf("\n Error: Could not create socket \n");
  }

  serv_addr.sin_family = AF_INET;
  serv_addr.sin_port   = htons(9999);

  if (inet_pton(AF_INET, HOSTNAME, &serv_addr.sin_addr) <= 0)
  {
    printf("\n Error: Connect Failed \n");
    exit(1);
  }

  connectToServer();
  createThreads();


  pthread_create(&input_thread, NULL, inputFunction, (void *)this);

  // TODO: Voice Recode
  return true;
}

void Client::startMainLoop()
{
  while (isRunning)
  {}
}

void Client::stopMainLoop()
{
  isRunning = false;
}

void Client::receiveMessage(const Message& m)
{}

bool Client::dispatchMessage(Message *m)
{
  bool bHandle = false;

  if (m->_impl->head->mh_handle_proxy == proxy_client)
  {
    printf("client dispatching message");

    if (m->_impl->head->mh_id == M_BEGIN_AUDIO_RECORDING) startAudioRecording();

    else if (m->_impl->head->mh_id == M_END_AUDIO_RECORDING) stopAudioRecording();


    bHandle = true;
  }
  else this->sendMessage(m);

  return bHandle;
}

#define FIFO_NAME "/tmp/osp.fifo"

int Client::sendCommand(char *cmd) {
  int fd = open(FIFO_NAME, O_WRONLY);

  if (write(fd, cmd, strlen(cmd)) == -1) {
    perror(":(");
    return -1;
  }

  close(fd);

  return 1;
}

void Client::startAudioRecording()
{
  printf("start Audio Recording\n");

  if (!isRecording)
  {
    sendCommand("start\r");
    isRecording = true;
  }
}

void Client::stopAudioRecording()
{
  printf("start Audio Recording\n");

  if (isRecording)
  {
    sendCommand("stop\r");
    isRecording = false;
  }
}
\end{lstlisting}





\begin{lstlisting}[caption=comm.h,language=C++]
#define LISTEN_THREAD 0
#define WRITE_THREAD  1
#define READ_THREAD   2
#define THREAD_NUM    3

#include <pthread.h>
#include "message_query.h"
#include "message.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

class Comm {
protected:

  struct sockaddr_in serv_addr;
  int server_socket;
  int client_socket;

  pthread_t threads[THREAD_NUM];
  int  thread_ids[THREAD_NUM];
  bool thread_running[THREAD_NUM];

public:

  MessageQuery *query;

public:

  Comm();
  ~Comm();

  void         createThreads();
  bool         isThreadRunning(int thread_index);

  int          sendMessage(Message *m);
  Message    * readMessage();
  virtual bool dispatchMessage(Message *m) = 0;
};

void         * writeThread(void *arg);
void         * readThread(void *arg);

\end{lstlisting}





\begin{lstlisting}[caption=comm.cpp,language=C++]
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define BUFFER_SIZE 1024

#include <iostream>
using std::cout;        using std::endl;

#include "comm.h"

Comm::Comm()
{
  query = MessageQuery::GetInstance();
  memset(thread_running, 1, THREAD_NUM);
}

Comm::~Comm()
{}

void Comm::createThreads()
{
  thread_ids[WRITE_THREAD] = pthread_create(&threads[WRITE_THREAD],
                                            NULL,
                                            writeThread,
                                            this);

  thread_ids[READ_THREAD] = pthread_create(&threads[READ_THREAD],
                                           NULL,
                                           readThread,
                                           this);
}

bool Comm::isThreadRunning(int thread_index)
{
  return thread_running[thread_index];
}

int Comm::sendMessage(Message *m)
{
  void *p = m->messageData();

  write(client_socket, p, m->messageLength());
  free(p);
  return 0;
}

Message * Comm::readMessage()
{
  char buffer[BUFFER_SIZE] = { 0 };
  int  count               = 0;

  count         = read(client_socket, buffer, sizeof(buffer) - 1);
  buffer[count] = 0;
  Message *m = Message::createMessage(buffer);
  return m;
}

void* writeThread(void *arg)
{
  Comm *s = (Comm *)arg;
  char  buffer[BUFFER_SIZE];

  while (s->isThreadRunning(WRITE_THREAD))
  {
    memset(buffer, 0, BUFFER_SIZE);
    Message *m = MessageQuery::GetInstance()->popMessage();
    s->sendMessage(m);
    delete m;
  }
  return NULL;
}

void* readThread(void *arg)
{
    printf("read thread start\n");

  Comm *s = (Comm *)arg;

  while (s->isThreadRunning(READ_THREAD))
  {
    Message *m = s->readMessage();
    printf("%s\n", m->messageBodyData());

    if (s->dispatchMessage(m)) delete(m);
  }
  return NULL;
}

\end{lstlisting}








\begin{lstlisting}[caption=main-client.cpp,language=C++]
#include "client.h"

int main(int argc, char **argv)
{
  Client *c = new Client();

  c->setUpService();
  c->startMainLoop();
  delete c;

  return 0;
}
\end{lstlisting}







\begin{lstlisting}[caption=message.h,language=C++]
#ifndef __MESSAGE_H__
#define __MESSAGE_H__

#include <string>
using std::string;

enum message_id
{
  M_START = 0,
  M_END,
  M_DETECTED,
  M_UNDETECTED,


  M_PIR_DETECTED = 100,
  M_PIR_UN_DETECTED,

  M_BEGIN_AUDIO_RECORDING = 200,
  M_END_AUDIO_RECORDING,
};

enum message_handle_proxy
{
  proxy_server,
  proxy_client,
};

struct message_head
{
  int mh_id;
  int mh_size;
  int mh_handle_proxy;
  int mh_reserve;
};

struct message_body
{
  int  mb_len;
  char mb_data[1];
};

struct message
{
  message_head *head;
  message_body *body;
};

class Client;

class Message {
  friend class Client;
  message *_impl;

public:

  Message();
  Message(const Message& other);
  Message& operator=(const Message& rhs);
  Message(void *data, int size);
  ~Message();

public:

  void            initMessage(int    id,
                              string message_data);
  int             messageLength() const;
  void          * messageData() const;
  char          * messageBodyData() const;
  int             getMessageHandleProxy(int id);

  static Message* createMessage(void *data);
};

#endif
\end{lstlisting}







\begin{lstlisting}[caption=message.cpp,language=C++]
#include "message.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

Message::Message()
{
  _impl       = new message();
  _impl->head = new message_head();
  _impl->body = (message_body *)malloc(sizeof(message_body));
}

Message::Message(const Message& other)
{
  _impl       = new message();
  _impl->head = new message_head();
  _impl->body = (message_body *)malloc(sizeof(message_body));

    memcpy(_impl, other._impl, sizeof(message));
}

Message& Message::operator=(const Message& rhs)
{
  if (&rhs != this)
  {
    _impl       = new message();
    _impl->head = new message_head();
    _impl->body = (message_body *)malloc(sizeof(message_body));

    memcpy(_impl, rhs._impl, sizeof(message));
  }

  return *this;
}

Message::~Message()
{
  delete _impl->head;
  delete _impl->body;
  delete _impl;
}

Message * Message::createMessage(void *data)
{
  Message *m = new Message();

  int *p = (int *)data;

  m->_impl->head->mh_id           = *(p + 0);
  m->_impl->head->mh_size         = *(p + 1);
  m->_impl->head->mh_handle_proxy = *(p + 2);
  m->_impl->head->mh_reserve      = *(p + 3);
  char *c   = (char *)((p + 4) + 1);
  int   len = strlen(c);
  m->_impl->body         = (message_body *)malloc(
    sizeof(char) * (len + 1) + sizeof(int));
  m->_impl->body->mb_len = *(p + 4);
    memcpy(m->_impl->body->mb_data, c, len);
  m->_impl->body->mb_data[len] = 0;

  return m;
}

void Message::initMessage(int id, string message_data)
{
  _impl->head->mh_id = id;

  _impl->head->mh_handle_proxy = getMessageHandleProxy(id);
  _impl->head->mh_reserve      = 0;

  _impl->body = (message_body *)malloc(sizeof(int) +
                                       sizeof(char) * (message_data.size() + 1));
  _impl->body->mb_len = message_data.size();
    memcpy(_impl->body->mb_data, message_data.c_str(), message_data.size());
  *(_impl->body->mb_data + message_data.size()) = 0;

  _impl->head->mh_size = sizeof(message_head) + sizeof(int)
                         + sizeof(char) * (message_data.size() + 1);
}

int Message::messageLength() const
{
  return _impl->head->mh_size;
}

void * Message::messageData() const
{
  void *p = malloc(messageLength());

  memset(p, 0, messageLength());
  memcpy(p, _impl->head, sizeof(message_head));
  int *pi = ((int *)p + 4);
  *pi = _impl->body->mb_len;
  char *c = (char *)(pi + 1);
  memcpy(c, _impl->body->mb_data, _impl->body->mb_len);
  c[_impl->body->mb_len] = 0;
  return p;
}

char * Message::messageBodyData() const
{
  return _impl->body->mb_data;
}

int Message::getMessageHandleProxy(int id)
{
  int reVal = -1;

  switch (id)
  {
  case M_START:
  case M_END:
  case M_DETECTED:
  case M_UNDETECTED:
  case M_PIR_DETECTED:
  case M_PIR_UN_DETECTED:
    reVal = proxy_server;
    break;

  case M_BEGIN_AUDIO_RECORDING:
  case M_END_AUDIO_RECORDING:
    reVal = proxy_client;
    break;
  }
  return reVal;
}
\end{lstlisting}







\begin{lstlisting}[caption={message\_query.h},language=C++]
#ifndef __MESSAGE_QUERY_H__
#define __MESSAGE_QUERY_H__

#include <list>
#include <pthread.h>
#include "singleton.h"
using std::list;

class Message;

class MessageQuery : public Singleton<MessageQuery>{
  list<Message *> _query;

  pthread_mutex_t _mutex;
  pthread_cond_t  _con;

public:

  MessageQuery();
  ~MessageQuery();

  void     pushMessage(Message *m);
  Message* popMessage();
};

#endif
\end{lstlisting}







\begin{lstlisting}[caption=message-query.cpp,language=C++]
#include "message_query.h"
#include "message.h"

MessageQuery::MessageQuery()
{
  pthread_mutex_init(&_mutex, NULL);
  pthread_cond_init(&_con, NULL);
}

MessageQuery::~MessageQuery()
{
  pthread_mutex_destroy(&_mutex);
  pthread_cond_destroy(&_con);
}

void MessageQuery::pushMessage(Message *m)
{
  pthread_mutex_lock(&_mutex);
  _query.push_back(m);
  pthread_cond_signal(&_con);
  pthread_mutex_unlock(&_mutex);
}

Message * MessageQuery::popMessage()
{
  pthread_mutex_lock(&_mutex);

  while (_query.empty()) pthread_cond_wait(&_con, &_mutex);

  Message *reVal = _query.front();
  _query.pop_front();
  pthread_mutex_unlock(&_mutex);
  return reVal;
}
\end{lstlisting}







\begin{lstlisting}[caption=singleton.h,language=C++]
#ifndef __SINGLETON_H__
#define __SINGLETON_H__

template<typename T>
class Singleton {
protected:

  static T *_instance;

public:

  static T* GetInstance()
  {
    if (!_instance) _instance = new T();

    return _instance;
  }
};

template<typename T>
T * Singleton<T>::_instance = 0;

#endif

\end{lstlisting}






\begin{lstlisting}[caption=osp-project-client.service,language=bash]
[Unit]
Description=OSP Project Daemon
After=syslog.target 

[Service]
Type=oneshot
User=audio
Group=audio
ExecStart=/usr/local/bin/osp_client
ExecStart=/usr/bin/python /var/osp/pipe.py
ExecStop=/bin/killall osp_client
ExecStop=/bin/killall python
Restart=on-abort

[Install]
WantedBy=multi-user.target
\end{lstlisting}


\begin{lstlisting}[caption=limits.conf,language=bash]
*               -       rtprio          0
*               -       nice            0
@audio          -       rtprio          65
@audio          -       nice           -25
@audio          -       memlock         40000
\end{lstlisting}


\begin{lstlisting}[caption=audio-daemon.py,language=python]
#!/usr/bin/env python

import sys
import os
import time
import getopt
import atexit
import alsaaudio
from daemon import Daemon

def get_fname():
    prefix = "/root/audio/output/recording_"
    return prefix + time.strftime("%d-%m-%y_%H-%M", time.gmtime()) + '.wav'

def shutdown(daemon, pipename):
    daemon.cleanup()
    os.remove(pipename)
    print("Shutting down")
    
class Recording(Daemon):
    def cleanup(self):
        # convert to mp3 and die
        pass

    def run(self):
        card = 'default'
        f = open(get_fname(), 'wb')

        inp = alsaaudio.PCM(alsaaudio.PCM_CAPTURE, alsaaudio.PCM_NONBLOCK, card)

        # Set attributes: Mono, 44100 Hz, 16 bit little endian samples
        inp.setchannels(1)
        inp.setrate(44100)
        inp.setformat(alsaaudio.PCM_FORMAT_S16_LE)

        inp.setperiodsize(160)
        while True:
           # Read data from device
            l, data = inp.read()
          
            if l:
                f.write(data)
                time.sleep(.001)
        f.close()

if __name__ == "__main__":
    named_pipe = '/tmp/osp.fifo'
    command = ''
    daemon = Recording('/tmp/recording_daemon.pid')

    try:
        os.mkfifo(named_pipe)
    except OSError:
        print("Error creating pipe, guess it exists")
        #sys.exit(1)

    while command != 'shutdown':
        pipe = open(named_pipe, 'r')
        command = pipe.read()[:-1]
        print("command received: %s" % command)
        if command == 'start':
            print("starting recording")
            a = os.fork()
            if a == 0:
                daemon.start()
        if command == 'stop':
            print("stopping recording")
            daemon.stop()
        if command == 'shutdown':
            print("stopping recording")
            os.kill(a, 0)
            daemon.stop()
            pipe.close()

    atexit.register(shutdown, daemon, named_pipe)
\end{lstlisting}

